cmake_minimum_required(VERSION 3.21)

# START: FIND VCPKG TOOLCHAIN FILE
set(NO_VCPKG_TOOLCHAIN_FILE TRUE)
foreach (THE_TOOLCHAIN_FILE ${CMAKE_TOOLCHAIN_FILE} ${CMAKE_TOOLCHAIN_FILE_OVERRIDE})
    if (${THE_TOOLCHAIN_FILE} MATCHES "vcpkg.cmake" AND EXISTS ${THE_TOOLCHAIN_FILE})
        set(NO_VCPKG_TOOLCHAIN_FILE FALSE)
    endif ()
    if (NOT NO_VCPKG_TOOLCHAIN_FILE)
        break () # there is a vcpkg toolchain file
    endif ()
endforeach ()
if (${NO_VCPKG_TOOLCHAIN_FILE})
    if (DEFINED ENV{VCPKG_ROOT} AND EXISTS "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake")
        list(APPEND CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake")
    elseif (DEFINED ENV{VCPKG_DIR} AND EXISTS "$ENV{VCPKG_DIR}/scripts/buildsystems/vcpkg.cmake")
        list(APPEND CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_DIR}/scripts/buildsystems/vcpkg.cmake")
    else ()
        message(FATAL_ERROR "No VcPkg toolchain file found")
    endif ()
endif ()
## END: FIND VCPKG TOOLCHAIN FILE

# Read the vcpkg.json file
file(READ "${CMAKE_SOURCE_DIR}/vcpkg.json" VCPKG_JSON_RAW)
# Parse "version-string" from JSON content
string(JSON VCPKG_JSON_VERSION_STRING GET ${VCPKG_JSON_RAW} "version-string")


# Project information
project(HelloWorldProject VERSION ${VCPKG_JSON_VERSION_STRING} LANGUAGES CXX)
set(THIS_EXEC hello_world)

# Generate version.h file
set(GENERATED_SOURCE_FILES_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated")
file(MAKE_DIRECTORY ${GENERATED_SOURCE_FILES_DIR})
file(WRITE "${GENERATED_SOURCE_FILES_DIR}/version.h"
        "#pragma once\n"
        "// This file is generated by CMake\n"
        "// Do not edit this file\n"
        "#define ${PROJECT_NAME}_VERSION_STRING \"${VCPKG_JSON_VERSION_STRING}\"\n"
        "#define ${PROJECT_NAME}_VERSION_MAJOR ${${PROJECT_NAME}_VERSION_MAJOR}\n"
        "#define ${PROJECT_NAME}_VERSION_MINOR ${${PROJECT_NAME}_VERSION_MINOR}\n"
        "#define ${PROJECT_NAME}_VERSION_PATCH ${${PROJECT_NAME}_VERSION_PATCH}\n"
    )

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(fmt CONFIG REQUIRED)
find_package(Boost REQUIRED COMPONENTS unit_test_framework)

# MAIN TARGET
add_executable( ${THIS_EXEC}
        src/main.cpp
    )
target_link_libraries(${THIS_EXEC}
    PRIVATE
        fmt::fmt
    )
target_include_directories(${THIS_EXEC}
    PRIVATE
        ${GENERATED_SOURCE_FILES_DIR}
    )

# TEST TARGET
add_executable(test_${THIS_EXEC}
        tests/test_main.cpp
    )

target_link_libraries(test_${THIS_EXEC} PRIVATE Boost::unit_test_framework)

include(CTest)
add_test(NAME test_${THIS_EXEC} COMMAND test_${THIS_EXEC})

# Copy the properties from the main target to the test target
function(COPY_PROPERTY_FROM_TARGET_TO_TARGET target_from target_to property_name)
    get_property(the_property TARGET ${target_from} PROPERTY ${property_name})
    if (NOT the_property STREQUAL "the_property-NOTFOUND")
        set_property(TARGET ${target_to} PROPERTY ${property_name} ${the_property})
    endif()
endfunction()
COPY_PROPERTY_FROM_TARGET_TO_TARGET(${THIS_EXEC} test_${THIS_EXEC} COMPILE_DEFINITIONS)
COPY_PROPERTY_FROM_TARGET_TO_TARGET(${THIS_EXEC} test_${THIS_EXEC} COMPILE_OPTIONS)
COPY_PROPERTY_FROM_TARGET_TO_TARGET(${THIS_EXEC} test_${THIS_EXEC} LINK_LIBRARIES)
COPY_PROPERTY_FROM_TARGET_TO_TARGET(${THIS_EXEC} test_${THIS_EXEC} LINK_DIRECTORIES)
COPY_PROPERTY_FROM_TARGET_TO_TARGET(${THIS_EXEC} test_${THIS_EXEC} INCLUDE_DIRECTORIES)
# End of copying properties


# Install the dependencies to the install directory
install(TARGETS ${THIS_EXEC} RUNTIME DESTINATION ./)
get_property (this_target_linked_libs TARGET ${THIS_EXEC} PROPERTY LINK_LIBRARIES)
foreach (lib IN LISTS this_target_linked_libs)
    if (${CMAKE_BUILD_TYPE} STREQUAL "Debug")
        get_target_property (lib_location ${lib} LOCATION_DEBUG)
    else ()
        get_target_property (lib_location ${lib} LOCATION_RELEASE)
    endif ()
    if (lib_location)
        install (FILES ${lib_location} DESTINATION ./ CONFIGURATIONS ${CMAKE_BUILD_TYPE})
    endif ()
endforeach ()

# Packaging information
include(InstallRequiredSystemLibraries)
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/License.txt")
set(CPACK_SET_DESTDIR  "${CMAKE_CURRENT_SOURCE_DIR}/installers/")
set(CPACK_PACKAGE_VERSION_MAJOR "${${PROJECT_NAME}_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${${PROJECT_NAME}_VERSION_MINOR}")
set(CPACK_PACKAGE_VERSION_PATCH "${${PROJECT_NAME}_VERSION_PATCH}")
set(CPACK_PACKAGE_CONTACT "Ishansh Lal <t.RED.0_0@proton.me>")

# For creating installers for Platforms
if (${CMAKE_SYSTEM_NAME} MATCHES "Windows")
    set(CPACK_GENERATOR "NSIS")
elseif (${CMAKE_SYSTEM_NAME} MATCHES "Linux")
    set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Ishansh Lal <t.RED.0_0@proton.me>")
    set(CPACK_GENERATOR "DEB")
endif()
include(CPack)
